#Author: Ang A. Tu
#Purpose: This script assumes that we have a seurat object named umi_seurat that was already generated by processing the
# gene expression matrix. It also assumes that we have a object named BCSeq that contains all of the cell barcodes of 
# the cells in the seurat object. The goal is to incorporate the processed TCR information (from the TCR mapping summary
# files)and generate basic coverage statistics and graphs.

#Known problems: if one of the samples in the seurat object has 0 coverage (i.e. no recovered TCR), some of the graph may
# not generate correctly (but the resulting seurat object will still be correct). 

#We're still assuming that we're using Seurat 2.3.4. Most commands should still work for Seurat 3 just fine.

# Load Packages and set Common Parameters ---------------------------------
library(Seurat)
library(tidyverse)
library(viridis)
library(RColorBrewer)
library(pheatmap)

cbPalette <- c("gray87", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

function_file<-choose.files(caption="Choose scripts that contain common functions")
source(function_file)

graphing_parameters <- choose.files(caption="Choose scripts that contain graphing parameters")
source(graphing_parameters)
# Functions ---------------------------------------------------------------

# most of the functions should be in the function file laoded above
#Below are some of the functions of the exapnaded cloens that we need to look at
#Xlist is really a vector of the sample names. seurat_obj is the seurat object that has TRB information
Shared_TRB_fn<- function(seurat_obj, xlist, group.var = orig.ident){
  if(length(xlist)<2){return("list must be 2 or longer")}
  group.var <- enquo(group.var)
  common_clones <- seurat_obj@meta.data %>% filter(!!group.var %in% xlist[1]) %>% filter(!is.na(TRB_CDR3)) %>%
    select(TRBV,TRBJ,TRB_CDR3)
  for(x in xlist[2:length(xlist)]){
    temp <- seurat_obj@meta.data %>% filter(!!group.var %in% x) %>% filter(!is.na(TRB_CDR3)) %>% select(TRBV,TRBJ,TRB_CDR3)
    common_clones <- intersect(common_clones, temp)
  }
  return(as.tibble(common_clones))
}

#now we do the same generalized function for 
Shared_TRA_fn<- function(xlist){
  if(length(xlist)<2){return("list must be 2 or longer")}
  common_clones <- umi_seurat@meta.data %>% filter(orig.ident %in% xlist[1]) %>% filter(!is.na(TRA_CDR3)) %>%
    select(TRAV,TRAJ,TRA_CDR3)
  for(x in xlist[2:length(xlist)]){
    temp <- umi_seurat@meta.data %>% filter(orig.ident %in% x) %>% filter(!is.na(TRA_CDR3)) %>% select(TRAV,TRAJ,TRA_CDR3)
    common_clones <- intersect(common_clones, temp)
  }
  return(common_clones)
}

#this function takes a data frame, and then count the particular thing that wants to be counted, 
#names and then redo the column names
#x is the input dataframe, and TR is the object to be counted
#the enquo thing seems only necessary with column names
Count_fn <- function(x, TR = TRB_CDR3, sort = TRUE){
  if(!is.data.frame(x)){return("please enter dataframe")}
  tocount <- enquo(TR)
  x %>% count(!!tocount,sort) -> counted
  colnames(counted) <- c(deparse(substitute(TR)), "frequency")
  return(counted)
}
#The next funciton would take a list of TRB or TRA, and then find the matching TRA or TRB, and all the other 
#Basically something that we wrote above, but into a simpler function
#here x is the sample name, and TR_list is the dataframe with TRB to be found. Mostly generated by the "Shared..." fns
Match_TRA_fn <- function(x, TR_list){
  umi_seurat@meta.data %>% filter(orig.ident %in% x) -> x_TR_df
  x_TR_df %>% filter(TRB_CDR3 %in% TR_list$TRB_CDR3) %>% select(TRBV,TRBJ,TRB_CDR3,TRAV,TRAJ,TRA_CDR3,cluster,cell_id) %>%
    arrange(TRB_CDR3,TRA_CDR3) -> x_TR_final
  return(x_TR_final)
}
#Same function, but for finding matched TRB
Match_TRB_fn <- function(x, TR_list){
  umi_seurat@meta.data %>% filter(orig.ident %in% x) -> x_TR_df
  x_TR_df %>% filter(TRA_CDR3 %in% TR_list$TRA_CDR3) %>% select(TRBV,TRBJ,TRB_CDR3,TRAV,TRAJ,TRA_CDR3,cluster,cell_id) %>%
    arrange(TRA_CDR3,TRB_CDR3) -> x_TR_final
  return(x_TR_final)
}

#other things that we want to do is actually to start breaking down the proportion of clones. 
#For example, how much does the top 10 clones actually dominate in terms of distribution.

#generalize the counting 
Count_clones_TRB <- function(){
  #This just gerenates a dataframe of sample ID, TRB CDR3, and frequency
  umi_seurat@meta.data %>% group_by(orig.ident) %>% filter(!is.na(TRB_CDR3)) %>%dplyr::count(TRB_CDR3,sort = TRUE) -> count_df
  colnames(count_df) <- c("orig.ident", "TRB_CDR3","frequency")
  return(as.data.frame(count_df))
}
Clonal_proportion <- function(x,bin.size = 10){
  #x is a  sample name
  count_df<-Count_clones_TRB()
  #then I think I want to pull out the count for each of the samples.then i'm not sure.
  count_df_x <- count_df %>% filter(orig.ident %in% x)
  total_rows <- count_df_x %>% nrow()
  #set intervals to group clones
  singletons_rows <- count_df_x %>% filter(frequency==1) %>% nrow()
  if(round(total_rows-singletons_rows,-1) == 0){
    seq.max = round(total_rows-singletons_rows)
  }
  else{
    seq.max = round(total_rows-singletons_rows, -1)
  }
  intervals <- c(seq(0,seq.max,bin.size),total_rows)
  #print(bin.size)
  text_labels <- intervals[-1]
  print(text_labels)
  if(bin.size > 1){
  	text_labels[-1] <- paste(text_labels+1,lead(text_labels), sep = "-")
  	text_labels[1] <- paste(1,text_labels[1],sep = "-")
  }
  #text_labels[1] <- paste("top",text_labels[1])
  cut(row(count_df_x[1]),intervals, labels = text_labels) -> interval_labels
  cbind(count_df_x,intervalL = interval_labels) -> count_df_x
  #We'll save our data to another data frame. Initiate the dataframe here
  output <- data.frame(interval = levels(interval_labels), placeholder = NA)
  names(output)[2] <- x
  #then we should have a data frame with columns of interval, sample name (x), and NA in each of the categories
  #how do we calculate the sum?
  clone_sum = sum(count_df_x$frequency)
  for(y in output$interval){
    count_df_x %>% filter(intervalL == y) %>% ungroup() %>% select(frequency) %>% sum() -> temp
    index <- match(y,output$interval)
    output[index,2]<- temp/clone_sum
  }
  return(output)
}
#Ideally, we'd write a graphing code that would combine the individual dataframe into a single data frame, 
#so the labels would be consistent. can use the merge function here.
Proportion_df<-function(xlist, bin.size = 10){
  output <- data.frame() #initialize our output data frame.
  for(x in xlist){
    if(nrow(output) == 0){
      temp<- Clonal_proportion(x, bin.size)
      temp$interval <- as.character(temp$interval)
      temp$interval[length(temp$interval)] <- "Singletons"
      temp$interval <- as.factor(temp$interval)
      #levels(temp$interval)<- c(levels(temp$interval),"Singletons")
      output<- temp}
    else {
      temp<- Clonal_proportion(x, bin.size)
      temp$interval <- as.character(temp$interval)
      temp$interval[length(temp$interval)] <- "Singletons"
      temp$interval <- as.factor(temp$interval)
      #temp<- droplevels(temp)
      #levels(temp$interval)<- c(levels(temp$interval),"Singletons")
      #print(levels(temp$interval))
      output <- merge(output,temp,by="interval", all = TRUE)
    }
  }
  output[is.na(output)] <- 0
  return(output)
}

#here I think first focus on generating the dataset that can be plug into a heatmap
Shared_TRB_heatmap <- function(seurat_obj,xlist){
	size <- length(xlist)
	output <- matrix(0,size,size)
	colnames(output)<-c(xlist)
	rownames(output)<-c(xlist)
	#then I think we use shared_TRB_fn, unfortunately, using sapply and lapply are a bit too complicated. Will 
	#keep to basic loops for now. sapply here just makes pairs of samples, iteratively
	for(x in xlist){
		sapply(xlist,c,x) -> pairs
		for(i in 1:size){
		nrow(Shared_TRB_fn(seurat_obj,pairs[,i])) -> output[x,i]
			}
		}
return(output)
}
# Loading files -----------------------------------------------------------

file<-choose.files(caption="Matching sample TCR mapping summary files") # can choose multiple files

#Now this will concatenate all of the chosen files into one data-frame
TCR_df <- bind_rows(lapply(file, read_tsv))

# Clean & Format ----------------------------------------------------------
# Then let's clean cast some variable into usable formats, and clean and rearange the dataframe

TCR_df <- TCR_df %>% mutate(TopVregion = factor(TopVregion), TopJregion = factor(TopJregion))
TCR_df_cleaned <- TCR_df %>% filter(!is.na(CDR3)) %>% arrange(BC, desc(nReads))

# Quantify how many UMI each CDR3 has, and then sort the files by UMI, then by reads.

# create a second df that records (BC,CDR3) combination and their respective UMI_count, then combine it into the df
TCR_df_cleaned_UMI_count <- TCR_df_cleaned %>% count(BC, CDR3) %>% rename(UMI_count = n)
TCR_df_cleaned<-left_join(TCR_df_cleaned, TCR_df_cleaned_UMI_count, by = c('BC','CDR3'))

# reorder and sort
TCR_df_cleaned<- TCR_df_cleaned %>% select(UMI_Name,BC,UMI,UMI_count,nReads,everything())
TCR_df_cleaned<- TCR_df_cleaned[with(TCR_df_cleaned,order(BC,UMI_count,nReads,decreasing=TRUE)),]

# Separate df into alpha and beta chain into two dataframes
TRA_df <- TCR_df_cleaned %>% filter(str_detect(TopVregion, "^TRAV"))
TRB_df <- TCR_df_cleaned %>% filter(str_detect(TopVregion, "^TRBV"))

# Put the CDR3 info intoi the meta-data frame -----------------------------

#Then we should generate masks of matching barcodes. We would probably have to do two masks
#Note: these values are just masks that apply to TRA/TRB_df list of values. i.e. it gives indices of where in the 
# TRA/TRB_df, do you find the correspoding rank position of the same cell (i.e. first position is first cell in 
# the BCSeqlist.) BCSeq has to be the total list of barcodes for all of the cells in the Seurat object
is.na(match(BCSeq, TRA_df$BC)) == 0 -> TRA_BC 
is.na(match(BCSeq, TRB_df$BC)) == 0 -> TRB_BC 
TRA_BC & TRB_BC ->TRAB_BC


#here we construct the mapping necessary to look at mapping statistics 
umi_seurat@meta.data$TCR_Recovery <- "No Recovery"
umi_seurat@meta.data$TCR_Recovery[c(TRB_BC)] <- "TRB only"
umi_seurat@meta.data$TCR_Recovery[c(TRA_BC)] <- "TRA only"
umi_seurat@meta.data$TCR_Recovery[c(TRAB_BC)] <- "TRA and TRB"

#Once we get to here, we can do some spot checks. 
#do: 

#TSNEPlot(umi_seurat, group.by = "TCR_Recovery", colors.use = c(cbPalette), 
# do.hover = TRUE, data.hover = "ident")

#and look at specific points, and find their cell identity name
#then do: BCSeq[match("cellname",names(umi_seurat@ident))]

#to find teh particular barcode, then we could check to see if that barcode actually exist in our TCR data
#VlnPlot(umi_seurat,c("TRBC2", "TRAC"), group.by = "TCR_Recovery")

# match TRB information into umi_seurat
umi_seurat@meta.data$TRB_CDR3 <- "No Recovery"
umi_seurat@meta.data$TRB_CDR3 <- TRB_df$CDR3[match(BCSeq,TRB_df$BC)]
umi_seurat@meta.data$TRBV <- TRB_df$TopVregion[match(BCSeq,TRB_df$BC)]
umi_seurat@meta.data$TRBJ<- TRB_df$TopJregion[match(BCSeq,TRB_df$BC)]

#First we get rid of the duplicates of the TRA

TRA_df %>% distinct(BC,CDR3,TopVregion, .keep_all = TRUE) -> TRA_uniq_df

match(BCSeq,TRA_uniq_df$BC) -> TRA1_Match

umi_seurat@meta.data$TRA_CDR3 <- "No Recovery"
umi_seurat@meta.data$TRA_CDR3 <- TRA_uniq_df$CDR3[TRA1_Match]
umi_seurat@meta.data$TRAV <- TRA_uniq_df$TopVregion[TRA1_Match]
umi_seurat@meta.data$TRAJ<- TRA_uniq_df$TopJregion[TRA1_Match]

# then we remove the rows that we just assigned. This takes advantage of the fact that match only make the first mathes.
# so after the first match, and barcode that have a second TCRA is still left.
TRA1_Match_filter <- TRA1_Match[!is.na(TRA1_Match)]
TRA2_uniq_df <- TRA_uniq_df[-TRA1_Match_filter, ]

# match second TCRA if there is one.
match(BCSeq,TRA2_uniq_df$BC) -> TRA2_Match

umi_seurat@meta.data$TRA.2_CDR3 <- NA
umi_seurat@meta.data$TRA.2_CDR3 <- TRA2_uniq_df$CDR3[TRA2_Match]
umi_seurat@meta.data$TRAV.2 <- TRA2_uniq_df$TopVregion[TRA2_Match]
umi_seurat@meta.data$TRAJ.2<- TRA2_uniq_df$TopJregion[TRA2_Match]

#Need to eventually move to using dplyr solutions

#The CDR3 and V region makes a couple assumptionS. In cases where we are getting multiple CDR3, it picks
#the first match, which in this case is one with more UMI, then ones with more reads.
#Right now, we allow multiple Alphas, but only consider one Beta chain.

#Up to this point, We have integrated the TCR data into seq-well.

pdf("TCR_coverage.pdf")
TSNEPlot(umi_seurat, group.by = "TCR_Recovery", colors.use = c(cbPalette))
dev.off()

# Calculate Coverage Statistics -------------------------------------------

# generate more graphs about coverage statistics

cell_ident_df <- data.frame(name = names(umi_seurat@ident), ident = umi_seurat@ident)
rownames(cell_ident_df) <- c()

#then generate the list of identities previously identified by Seurat
ident_list <- levels(umi_seurat@ident)

# iteratively look through TRA, TRB, TRA and TRB statistics for each cluster ident
TRA_stat <- c()
TRB_stat <- c()
TRAB_stat <- c()
for (i in ident_list){
	is.na(match(cell_ident_df$ident, i)) == 0 -> mask
	sub_total <- sum(mask)
	TRA_stat <- c(TRA_stat, sum(TRA_BC[c(mask)])/sub_total)
	TRB_stat <- c(TRB_stat, sum(TRB_BC[c(mask)])/sub_total)
	TRAB_stat <- c(TRAB_stat, sum(TRAB_BC[c(mask)])/sub_total)
}

# After iterating through the specific cluster list, do one last iteration to get the total stat
ident_list <- c(ident_list,"Total")
TRA_stat <- c(TRA_stat, sum(TRA_BC)/length(TRA_BC))
TRB_stat <- c(TRB_stat, sum(TRB_BC)/length(TRB_BC))
TRAB_stat <- c(TRAB_stat, sum(TRAB_BC)/length(TRAB_BC))

Coverage_summary_df <- data.frame(Cluster = ident_list,TRA = TRA_stat,TRB = TRB_stat,TRAB = TRAB_stat)

# plot data that we just generated

Coverage_summary_long<-reshape2::melt(Coverage_summary_df,id.vars="Cluster")

Coverage_bar <- ggplot(data = Coverage_summary_long, aes(x = Cluster, y = value, fill = variable)) +
				geom_bar(stat = "identity",position="dodge", color = "black") + scale_x_discrete(limits = ident_list) +
				scale_fill_manual("Coverage", values = c("TRA" = cbPalette[3], "TRB" = cbPalette[4], "TRAB" = cbPalette[2])) +
				labs(title = "Coverage statistics by clusters", y = "Fraction Recovered (0-1)") + 
				geom_text(aes(label = round(value,digits = 2)),vjust = -0.3, size = 2,position = position_dodge(width=0.9)) +
				theme_minimal()

pdf("TCR_coverage_by_cluster.pdf", width = 11, height = 8)
Coverage_bar
dev.off()

sample_list <- levels(umi_seurat@meta.data$orig.ident)
TRA_stat_sample <- c()
TRB_stat_sample <- c()
TRAB_stat_sample <- c()

for (i in sample_list){
  is.na(match(umi_seurat@meta.data$orig.ident, i)) == 0 -> mask
  sub_total <- sum(mask)
  TRA_stat_sample <- c(TRA_stat_sample, sum(TRA_BC[c(mask)])/sub_total)
  TRB_stat_sample <- c(TRB_stat_sample, sum(TRB_BC[c(mask)])/sub_total)
  TRAB_stat_sample <- c(TRAB_stat_sample, sum(TRAB_BC[c(mask)])/sub_total)
}

Coverage_summary_sample_df <- data.frame(Sample = sample_list,TRA = TRA_stat_sample,TRB = TRB_stat_sample,TRAB = TRAB_stat_sample)

Coverage_summary_sample_long<-reshape2::melt(Coverage_summary_sample_df,id.vars="Sample")

Coverage_bar_sample <- ggplot(data = Coverage_summary_sample_long, aes(x = Sample, y = value, fill = variable)) +
  geom_bar(stat = "identity",position="dodge") + scale_x_discrete(limits = sample_list) +
  scale_fill_manual("Coverage", values = c("TRA" = cbPalette[3], "TRB" = cbPalette[4], "TRAB" = cbPalette[2])) +
  labs(title = "Coverage statistics by sample", y = "Fraction Recovered (0-1)") + 
  geom_text(aes(label = round(value,digits = 2)),vjust = -0.3, size = 2,position = position_dodge(width=0.9))

pdf("TCR_coverage_by_sample.pdf", width = 11, height = 8)
Coverage_bar_sample
dev.off()

# calculate V and J gene usage, and overall percentages of each gene segment

TRBV_summary <- table(umi_seurat@meta.data$TRBV)
TRBJ_summary <- table(umi_seurat@meta.data$TRBJ)

TRBV_summary_df <- data.frame(TRBV_summary)
TRBJ_summary_df <- data.frame(TRBJ_summary)

colnames(TRBV_summary_df) <- c("TRBV","Count")
colnames(TRBJ_summary_df) <- c("TRBJ","Count")

# Clean summary files of NA and irrelevant categories
TRBV_summary_df <- TRBV_summary_df[!(grepl("NA's",TRBV_summary_df$TRBV) | grepl("Other",TRBV_summary_df$TRBV)),]

library(data.table)
TRBV_summary_df <- TRBV_summary_df[TRBV_summary_df$TRBV %like% "TRBV", ]

TRBV_summary_df <- TRBV_summary_df[order(TRBV_summary_df$TRBV),]
rownames(TRBV_summary_df) <- c()

TRBV_bar <- ggplot(data = TRBV_summary_df, aes(x = TRBV, y = Count)) + 
			geom_bar(stat = "identity", width = 0.5, fill = cbPalette[4]) +
			theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.4)) +
			labs(title = "TRBV usage", y = "Count")

pdf("TRBV_usage.pdf", width = 11, height = 8)
TRBV_bar
dev.off()

# make a similar plot for TRA
TRAV_summary <- table(umi_seurat@meta.data$TRAV)
TRAJ_summary <- table(umi_seurat@meta.data$TRAJ)

TRAV_summary_df <- data.frame(TRAV_summary)
TRAJ_summary_df <- data.frame(TRAJ_summary)

colnames(TRAV_summary_df) <- c("TRAV","Count")
colnames(TRAJ_summary_df) <- c("TRAJ","Count")

TRAV_summary_df <- TRAV_summary_df[!(grepl("NA's",TRAV_summary_df$TRAV) | grepl("Other",TRAV_summary_df$TRAV)),]
TRAV_summary_df <- TRAV_summary_df[TRAV_summary_df$TRAV %like% "TRAV", ]
TRAV_summary_df <- TRAV_summary_df[order(TRAV_summary_df$TRAV),]
rownames(TRAV_summary_df) <- c()

TRAV_bar <- ggplot(data = TRAV_summary_df, aes(x = TRAV, y = Count)) + 
			geom_bar(stat = "identity", width = 0.5, fill = cbPalette[3]) +
			theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.4)) +
			labs(title = "TRAV usage", y = "Count")

pdf("TRAV_usage.pdf", width = 11, height = 8)
TRAV_bar
dev.off()

# do the same for TCR CDR3
TRB_CDR3_summary <- table(umi_seurat@meta.data$TRB_CDR3)
TRA_CDR3_summary <- table(umi_seurat@meta.data$TRA_CDR3)

TRB_CDR3_summary_df <- data.frame(TRB_CDR3_summary)
TRA_CDR3_summary_df <- data.frame(TRA_CDR3_summary)

colnames(TRB_CDR3_summary_df) <- c("CDR3","Count")
colnames(TRA_CDR3_summary_df) <- c("CDR3","Count")

TRB_CDR3_summary_df <- TRB_CDR3_summary_df[!(grepl("NA's",TRB_CDR3_summary_df$CDR3) | grepl("Other",TRB_CDR3_summary_df$CDR3)),]
TRA_CDR3_summary_df <- TRA_CDR3_summary_df[!(grepl("NA's",TRA_CDR3_summary_df$CDR3) | grepl("Other",TRA_CDR3_summary_df$CDR3)),]

# expansion mapping -------------------------------------------------------

TRB_CDR3_expanded <- TRB_CDR3_summary_df$CDR3[TRB_CDR3_summary_df$Count >3]
TRA_CDR3_expanded <- TRA_CDR3_summary_df$CDR3[TRA_CDR3_summary_df$Count >3]

umi_seurat@meta.data$TRB_expanded <- "Not Expanded/No Recovery"
"Expanded"->umi_seurat@meta.data$TRB_expanded[which(!is.na(match(umi_seurat@meta.data$TRB_CDR3, TRB_CDR3_expanded)))]

pdf("expanded TCRB.pdf", width = 11, height = 8)
TSNEPlot(umi_seurat, group.by = "TRB_expanded", colors.use = c(cbPalette[6],cbPalette[1]))
dev.off()

umi_seurat@meta.data$TRA_expanded <- "Not Expanded/No Recovery"
"Expanded"->umi_seurat@meta.data$TRA_expanded[which(!is.na(match(umi_seurat@meta.data$TRA_CDR3, TRA_CDR3_expanded)))]

pdf("expanded TCRA.pdf", width = 11, height = 8)
TSNEPlot(umi_seurat, group.by = "TRA_expanded", colors.use = c(cbPalette[8],cbPalette[1]))
dev.off()

# Add information about clonotype prevalence

umi_seurat@meta.data %>% count(TRB_CDR3) %>% filter(!is.na(TRB_CDR3)) -> TRB_CDR3_count
colnames(TRB_CDR3_count) <- c("TRB_CDR3","clones")

umi_seurat@meta.data %>% count(TRA_CDR3) %>% filter(!is.na(TRA_CDR3)) -> TRA_CDR3_count
colnames(TRA_CDR3_count) <- c("TRA_CDR3","clones")

umi_seurat@meta.data$cluster <- umi_seurat@ident
umi_seurat@meta.data$cell_id <- names(umi_seurat@ident)

# VJ-Freq -----------------------------------------------------------------

# plot V and J freq, which tells us for a given recovered TCR, how well do the called V and J gene agree with each other.
# anything below 0.5/1 is filtered out at a previous stage.
intervals<- c(0.50,0.60,0.70,0.80,0.90,1.00)
as.data.frame(table(cut(TCR_df$TopVFreq, intervals, include.lowest = TRUE))) -> TCR_df_VFreq
colnames(TCR_df_VFreq) <- c("Intervals","VFreq")

as.data.frame(table(cut(TCR_df$TopJFreq, intervals, include.lowest = TRUE))) ->  TCR_df_JFreq
colnames(TCR_df_JFreq) <- c("Intervals","JFreq")

merge(TCR_df_VFreq,TCR_df_JFreq,by="Intervals", all = TRUE) -> TCR_df_VJFreq
TCR_df_VJFreq$VFreq <-TCR_df_VJFreq$VFreq/sum(TCR_df_VJFreq$VFreq)
TCR_df_VJFreq$JFreq <-TCR_df_VJFreq$JFreq/sum(TCR_df_VJFreq$JFreq)

TCR_df_VJFreq_l <- melt(TCR_df_VJFreq)

pdf("VJFreq.pdf", width = 6, height = 8)
VJFreq_bar <- ggplot(data = TCR_df_VJFreq_l, aes(x = variable, y = value, fill = Intervals)) + 
  geom_bar(stat = "identity", color ="black") + theme_minimal()
VJFreq_bar
dev.off()


#first we need to decide what package we're going to use to generate the heatmap.


#The heatmap is still not optimized, but it'll work for now
Shared_TRB_heatmap(umi_seurat,sample_list) -> Public_TRB
for(i in 1:length(sample_list)){Public_TRB[i,i]<-NA}
pdf("TRB_heatmap.pdf", width = 6, height = 6)
pheatmap(Public_TRB, color = inferno(10), border_color = NA, drop_levels = TRUE, fontsize = 14, 
	main = "Shared TCRB", display_numbers = TRUE, number_format = "%.0f")
dev.off()

# sometimes I get a "count" error. in the code below. Which I think has to do with conflicting packages. reload the packages
# at the top (not load data.table)

Clonality_df <- Proportion_df(sample_list,10)
Clonality_dfl<- melt(Clonality_df)
Clonality_dfl$interval <- factor(Clonality_dfl$interval, 
                                 levels = levels(Clonality_dfl$interval)[order(nchar(levels(Clonality_dfl$interval)))]) 
#This line is for reordering plotting order. Change and modify as needed.

Clonality_dfl <- Clonality_dfl %>% mutate(variable = fct_relevel(variable,"AV",after = Inf))

Color_map_range<- brewer.pal(9,"Blues")
Color_map <- colorRampPalette(c(Color_map_range[c(9,1)]))
pdf("Clonality.pdf",width = 8, height = 6)
Clonality_bar <- ggplot(data = Clonality_dfl, aes(x = variable, y = value, fill = interval)) + 
	geom_bar(stat = "identity", color ="black") + theme_minimal() + 
	theme(axis.text.x = element_text(angle = 90, hjust = 0.5)) + scale_fill_manual("rank of clones", values = Color_map(length(levels(Clonality_dfl$interval)))) +
	labs(x = "Sample", y = "Fraction of total T cells", title = "TRB Clonal Proportion") + coord_flip()
Clonality_bar
dev.off()

rawdata_transpose <- t(umi_seurat@raw.data)
rawdata_transpose <- as.tibble(rawdata_transpose)

# then we filter for TRB genes, including J, D or constant
bin.size = 1
rawdata_transpose %>% select(starts_with("TRB")) -> rawdata_TRB
TRBC_intervals <- seq(-1,max(rawdata_TRB$TRBC2),bin.size)

cut(rawdata_TRB$TRBC2,TRBC_intervals, include.lowest = TRUE, labels =TRBC_intervals[-1]) -> TRBC2_bin
umi_seurat@meta.data$TRBC2_bin <- TRBC2_bin


# plot recovery against TCR constant transcripts-----------------------------------------------------------------

# not necessary to run, but the following just generates the plots that compare odds of TCR recovery against the number
# of constant region transcript we get in the transcriptomic data
umi_seurat@meta.data$TRB_Recovery <- "No Recovery"
umi_seurat@meta.data$TRB_Recovery[!is.na(umi_seurat@meta.data$TRB_CDR3)] <- "TRB Recovered"

umi_seurat@meta.data %>% group_by(TRBC2_bin) %>% dplyr::count(TRB_Recovery) -> recovery_v_TRBC_total
recovery_v_TRBC_total %>% group_by(TRBC2_bin) %>% filter(sum(n)>=100) %>% ungroup()%>%rename(cell_count = n) -> recovery_v_TRBC

# #now we want to change the grouping to add another column on top.
recovery_v_TRBC_total %>% group_by(TRBC2_bin) %>% filter(sum(n)<100) %>% ungroup() %>% group_by(TRB_Recovery) %>% summarise(cell_count = sum(n), TRBC2_bin = factor("16+")) -> temp #change factor label as necessary
bind_rows(recovery_v_TRBC,temp) %>% mutate(TRBC2_bin = factor(TRBC2_bin)) %>% mutate(TRBC2_bin = fct_inorder(TRBC2_bin)) -> recovery_v_TRBC

recovery_v_TRBC %>% group_by(TRBC2_bin) %>% mutate(n_percent_TRB = cell_count/sum(cell_count)) %>% ungroup()-> recovery_v_TRBC
recovery_v_TRBC_bar <- ggplot(data = recovery_v_TRBC) + geom_bar(mapping = aes(x = TRBC2_bin, y = cell_count, fill = TRB_Recovery),
	stat = "identity", color ="black") + theme_minimal() + theme(axis.text.x = element_text(angle = 0, hjust = 0.5))  +
	labs(x = "Number of TRBC transcript", y = "Count of T cells", title = "TRB recovery vs constant region mapping") +
	scale_fill_manual(values = cbPalette[c(1,4)])

TRBC_bin_total <- recovery_v_TRBC %>% group_by(TRBC2_bin) %>% summarise(Total_cells = sum(cell_count)) %>% ungroup()

recovery_v_TRBC_perc_bar <- ggplot(data = recovery_v_TRBC) + geom_bar(mapping = aes(x = TRBC2_bin, y = n_percent_TRB, fill = TRB_Recovery),
	stat = "identity", color ="black") + theme_minimal() + geom_text(mapping = aes(x = TRBC2_bin, y = 1, label = Total_cells), data = TRBC_bin_total, vjust = -1, size = 2.14) +
	theme(axis.text.x = element_text(angle = 0, hjust = 0.5))  +
	labs(x = "Number of TRBC transcript", y = "Fraction of T cells", title = "TRB recovery vs constant region mapping") +
	scale_fill_manual(values = cbPalette[c(1,4)]) + ylim(c(0.00,1.05))

rawdata_transpose %>% select(starts_with("TRA")) -> rawdata_TRA
TRAC_intervals <- seq(-1,max(rawdata_TRA$TRAC),bin.size)

cut(rawdata_TRA$TRAC,TRAC_intervals, include.lowest = TRUE, labels = TRAC_intervals[-1]) -> TRAC_bin
umi_seurat@meta.data$TRAC_bin <- TRAC_bin

umi_seurat@meta.data$TRA_Recovery <- "No Recovery"
umi_seurat@meta.data$TRA_Recovery[!is.na(umi_seurat@meta.data$TRA_CDR3)] <- "TRA Recovered"

umi_seurat@meta.data %>% group_by(TRAC_bin) %>% count(TRA_Recovery) -> recovery_v_TRAC_total
recovery_v_TRAC_total %>% group_by(TRAC_bin) %>% filter(sum(n)>=100) %>% ungroup() %>% rename(cell_count = n) -> recovery_v_TRAC

recovery_v_TRAC_total %>% group_by(TRAC_bin) %>% filter(sum(n)<100) %>% ungroup() %>% group_by(TRA_Recovery) %>% summarise(cell_count = sum(n),TRAC_bin = factor("4+")) -> temp #change factor label as necessary
bind_rows(recovery_v_TRAC,temp) %>% mutate(TRAC_bin = factor(TRAC_bin)) %>% mutate(TRAC_bin = fct_inorder(TRAC_bin)) -> recovery_v_TRAC

recovery_v_TRAC %>% group_by(TRAC_bin) %>% mutate(n_percent_TRA = cell_count/sum(cell_count)) %>% ungroup()-> recovery_v_TRAC

# 
recovery_v_TRAC_bar <- ggplot(data = recovery_v_TRAC) + geom_bar(mapping = aes(x = TRAC_bin, y = cell_count, fill = TRA_Recovery),
  stat = "identity", color ="black") + theme_minimal()+ theme(axis.text.x = element_text(angle = 0, hjust = 0.5)) +
	labs(x = "Number of TRAC transcript", y = "Count of T cells", title = "TRA recovery vs constant region mapping") +
	scale_fill_manual(values = cbPalette[c(1,3)])

TRAC_bin_total <- recovery_v_TRAC %>% group_by(TRAC_bin) %>% summarise(Total_cells = sum(cell_count)) %>% ungroup()

recovery_v_TRAC_perc_bar <- ggplot(data = recovery_v_TRAC) + geom_bar(mapping = aes(x = TRAC_bin, y = n_percent_TRA, fill = TRA_Recovery),
  stat = "identity", color ="black") + theme_minimal() + geom_text(mapping = aes(x = TRAC_bin, y = 1, label = Total_cells), data = TRAC_bin_total, vjust = -1, size = 2.14) +
	theme(axis.text.x = element_text(angle = 0, hjust = 0.5))  +
	labs(x = "Number of TRAC transcript", y = "Fraction of T cells", title = "TRA recovery vs constant region mapping") +
	scale_fill_manual(values = cbPalette[c(1,3)]) 
  ylim(c(0.00,1.05))

pdf("recover_v_constant_v2.pdf", width =4, height = 8)
plot_grid(recovery_v_TRBC_perc_bar, recovery_v_TRAC_perc_bar, labels = "AUTO", nrow = 2)
dev.off()